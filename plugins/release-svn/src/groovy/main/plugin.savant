import com.google.inject.Inject
import org.savantbuild.dep.DependencyManager
import org.savantbuild.domain.Version
import org.savantbuild.io.FileTools
import org.savantbuild.net.LocalSubVersion
import org.savantbuild.net.SubVersion
import org.savantbuild.run.output.Output

@Inject Output output
@Inject DependencyManager dm

target("release", description: "Releases all of the project's publications",
       params: [
           dir: [true, "The checkout directory"],
           type: [true, "The release type (f, t, p, d)"],
           skipTests: [false, "Determines if the tests are run during the release"],
           callback: [true, "Internal only"],
           dryRun: [false, "Internal only"]
       ]) << { params ->

  // Handle the callback and return
  if (params.containsKey('callback')) {
    callback(params['callback'], params.containsKey('dryRun'))
    return
  }

  sanityCheck()

  String dir = params['dir']
  if (dir == null) {
    dir = System.properties['user.home'] + "/.savant/release/${project.name}-" + new Date().format("yyyy-MM-dd-HmmS")
  }

  String type = params['type']
  if (type == null) {
    type = askForType();
  }

  String svnURL = LocalSubVersion.getProjectURL(new File('.'))
  if (svnURL.contains("tag")) {
    ant.fail "You cannot run a release from a tag."
  }

  String fullType = expandReleaseType(type);
  if (fullType == 'publish') {
    ant.input(message: 'Enter tag to deploy or publish (e.g. 1.0) ', addproperty: 'input.tag.version')
    String tag = ant.project.properties['input.tag.version']

    svnURL = LocalSubVersion.determineRoot(svnURL)
    output.info("Exporting the project from [${svnURL}/tags/${tag}] to [${dir}]")

    SubVersion svn = SubVersionTools.make(svnURL)
    svn.doExport("tags/${tag}", new File(dir))
    fork(dir, 'publish', true, false)
  } else {
    String scmLocation = LocalSubVersion.determineLocation(svnURL)
    String branch = LocalSubVersion.determineBranch(svnURL)
    svnURL = LocalSubVersion.determineRoot(svnURL)
    SubVersion svn = SubVersionTools.make(svnURL)

    if (scmLocation == 'trunk') {
      output.info("Checking out the project from [${svnURL}/trunk] to [${dir}]")
      svn.doCheckout('trunk', new File(dir))
    } else {
      output.info("Checking out the project from [${svnURL}/branches/${branch}] to [${dir}]")
      svn.doCheckout("branches/${branch}", new File(dir))
    }

    boolean skipTests = params.containsKey("skipTests")
    fork(dir, fullType, skipTests, (type == 'd'))
  }
}


void sanityCheck() {
  def f = new File('.svn')
  if (!f.exists()) {
    ant.fail "You can only run a release from a SVN checkout directory."
  }

  if (project.releaseWorkflow == null) {
    ant.fail "You must configure a release publish workflow to use the release-svn plugin"
  }

  if (SubVersionTools.hasModifications()) {
    ant.fail "The project has local modifications. You must commit or revert those changes (or put them on a branch)"
  }
}

void fork(String dir, String target, boolean skipTests, boolean dryRun) {
  String cmd
  if (System.getProperty("os.name").contains("Windows")) {
    String savantHome = System.properties['savant.home']
    cmd = "${savantHome}\\bin\\sb.bat"
  } else {
    cmd = "sb"
  }

  ant.exec(executable: cmd, dir: dir, failonerror: "true") {
    arg(line: "release ${dryRun ? "--dryRun" : ""} ${skipTests ? "--skipTests" : ""} --callback=${target}")
  }
}

String expandReleaseType(String type) {
  if (type == "f") {
    return "full"
  }
  if (type == "t") {
    return "tag"
  }
  if (type == "p") {
    return "publish"
  }
  if (type == "d") {
    return "full"
  }
  ant.fail "Invalid type"
}

String askForType() {
  output.info("""
There are 3 types of releases:
1. Full Release: check out, build, test, tag and branch, and deploy/publish.
2. Tag-Only Release: check out, build, test, and tag only. No Deployment/Publish will occur.
3. Publish Only: check out a tag, build, and publishes the artifact. No tagging and/or branching will occur.
4. Dry-run: runs a full release but doesn't tag or publish the artifact.
  """)
  ant.input(message: "Please indicate the release type: (f = Full, t = Tag-Only, p = Deploy/Publish-only, d = Dry-run) ", addproperty: "release.type", validargs: "f,t,p,d")
  return ant.project.properties['release.type']
}

void callback(String process, boolean dryRun) {
  String versionType = null
  Version ver = new Version(project.version)
  if (ver.isMajorVersion()) {
    versionType = "major"
  } else if (ver.isMinorVersion()) {
    versionType = "minor"
  } else if (ver.isSnapshot()) {
    versionType = "snapshot"
  } else if (ver.isPatchVersion()) {
    versionType = "patch"
  } else {
    ant.fail "Project version [${project.version}] is invalid or not a valid version number.\n" +
      "Please make sure that your version number meets the following criteria:\n" +
      "Major: X.0 where X > 0\nMinor: X.Y where X and Y > 0\nPatch: X.Y.Z where X, Z > 0 and Y >= 0\n" +
      "Snapshot: X.Y-RCn, X.Y-Bn, X.Y-An where X, n > 0 and Y >= 0 (RC = Release Candidate, B = Beta, A = Alpha"
  }

  output.info("Detected [${versionType}] version from [${project.version}]")

  switch(process) {
    case "tag":
      tag(versionType, dryRun)
      break;
    case "full":
      tag(versionType, dryRun)
      publish(dryRun, false)
      break;
    case "publish":
      publish(dryRun, true)
      break;
  }

  FileTools.prune(new File("."))
}

void tag(String versionType, boolean dryRun) {
  String svnURL = LocalSubVersion.getProjectURL(new File('.'))
  String scmLocation = LocalSubVersion.determineLocation(svnURL)
  if (versionType == "major" && scmLocation == "branch") {
    ant.fail 'You cannot release a major version from a branch.'
  }

  output.info("Running a ${versionType} tag release from ${scmLocation}")
  checkProjectForIntegrationBuilds()

  if (!SubVersionTools.isTagAvailable(project.version)) {
    ant.fail "Tag [${project.version}] already exists."
  }

  target("test").run()

  // Trunk handling and branch handling are slightly different here
  if (scmLocation == "trunk") {
    output.info("Copying from [trunk] to [tags/${project.version}]")
    if (!dryRun) {
      SubVersionTools.copy("trunk", "tags/${project.version}")
    }

    // If this isn't a tag release, create a branch
    if (versionType != "patch") {
      output.info("Copying from [trunk] to [branches/${project.version}]")
      if (!dryRun) {
        SubVersionTools.copy("trunk", "branches/${project.version}")
      }
    }
  } else {
    String branch = LocalSubVersion.determineBranch(svnURL)
    output.info("Copying from [branches/${branch}] to [tags/${project.version}]")
    if (!dryRun) {
      SubVersionTools.copy("branches/${branch}", "tags/${project.version}")
    }
  }
}

void publish(boolean dryRun, boolean runBuild) {
  if (dryRun) {
    return
  }

  if (runBuild) {
    target("pkg").run()
  }

  if (project.publications.size() > 0) {
    dm.publisher.publish(project, project.publications, project.releaseWorkflow, false)
  }
}

void checkProjectForIntegrationBuilds() {
  Map.Entry e = project.dependencies.find { key, value -> dm.publisher.hasIntegrations(value) }
  if (e != null) {
    ant.fail "The project depends on an integration build of an artifact in the [" +
        (e.key == null ? "default" : e.key) + "] dependencies.\nIf this is the [default] dependencies, that is the " +
        "dependency definition that does not have an ID.\nIf this is the [plugins] dependencies, that means your project " +
        "is using an integration build of a plugin"
  }
}
